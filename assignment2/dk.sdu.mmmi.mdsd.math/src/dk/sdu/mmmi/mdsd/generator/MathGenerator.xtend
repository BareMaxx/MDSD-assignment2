/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.MyNumber
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Var
import dk.sdu.mmmi.mdsd.math.Let
import dk.sdu.mmmi.mdsd.math.VariableUse
import dk.sdu.mmmi.mdsd.math.Par
import dk.sdu.mmmi.mdsd.math.External
import dk.sdu.mmmi.mdsd.math.Func
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Object> variables = new HashMap();
	static List<String> paramNames = newArrayList("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z")
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (program : resource.allContents.toIterable.filter(Program)) {
			
			fsa.generateFile("math_expression/" + program.name + ".java", program.compile)
		}
	}
	
	def compile(Program program) {
		variables.clear()
		'''
			package math_expression;
			public class «program.name» {
				«FOR variable : program.exp»
				public int «variable.name»;
				«ENDFOR»
				
				«IF !program.externals.isEmpty()»
				private External external;
				
				public «program.name»(External external) {
					this.external = external;
				}
				«ENDIF»
				
				public void compute() {
					«FOR variable: program.exp»
					«IF variable.getClass() != Let»
					«variable.name» = «variable.expression.computeExpression»;
					«ENDIF»
					«ENDFOR»	
				}
				
				«IF !program.externals.isEmpty()»
				public interface External {
					«FOR external: program.externals»
					public int «external.name»(«FOR param : external.params.indexed»«param.value» «paramNames.get(param.key)»«IF param.value !== external.params.last»,«ENDIF»«ENDFOR»);
					«ENDFOR»
				}	
				«ENDIF»
				
			}
		'''
	}
	
	def static dispatch computeExpression(Func function) {
		return '''external.«function.name»(«FOR param : function.args»«param.computeExpression»«IF param !== function.args.last»,«ENDIF»«ENDFOR»)'''
	}
	
	def static dispatch computeExpression(MyNumber exp) {
		return 
		'''«exp.value»'''
	}
	
	def static dispatch computeExpression(Plus exp) {
		return 
		'''(«exp.left.computeExpression» + «exp.right.computeExpression»)'''
	}
	
	def static dispatch computeExpression(Minus exp) {
		return
		'''(«exp.left.computeExpression» - «exp.right.computeExpression»)'''
	}
	
	def static dispatch computeExpression(Mult exp) {
		return
		'''(«exp.left.computeExpression» * «exp.right.computeExpression»)'''
	}
	
	def static dispatch computeExpression(Div exp) {
		return '''(«exp.left.computeExpression» / «exp.right.computeExpression»)'''
	}
	
	def static dispatch computeExpression(Par exp) {
		return '''(«exp.body.computeExpression»)'''
	}
	
	
	def static dispatch computeExpression(Let exp) {
		exp.body.computeExpression
	}
	
	def static dispatch computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch computeBinding(Var binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.	name)
	}
	
	def static dispatch computeBinding(Let binding){
		binding.binding.computeExpression
	}
	
	def static dispatch computeExpression(Var binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
	
	
	
}
